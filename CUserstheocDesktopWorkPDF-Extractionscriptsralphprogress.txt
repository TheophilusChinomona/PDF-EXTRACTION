## 2026-01-28 22:15 - US-022
- Implemented manual review queue system for failed extractions that exceed retry limits
- Created migrations/002_create_review_queue_table.sql with review_queue table
  - Table includes: id, extraction_id (FK), error_type, error_message, processing_method
  - Tracking fields: quality_score, retry_count, queued_at, reviewed_at, reviewer_notes
  - Resolution enum: fixed, false_positive, unable_to_process
  - Constraint ensures reviewed_at set when resolution is set
- Created app/db/review_queue.py with CRUD operations
  - add_to_review_queue(): Adds failed extraction to queue with error classification
  - get_pending_reviews(): Returns unresolved items with pagination (joins extractions table)
  - resolve_review(): Marks item as reviewed with resolution and notes
  - get_review_by_id(): Retrieves specific review item with extraction context
- Updated app/routers/extraction.py to queue failed extractions
  - When retry_count > 5, extraction status set to 'failed' instead of raising 500 error
  - Automatically adds to review queue with error type classification
  - Handles failed extractions without ExtractionResult using update_extraction_status()
  - Returns 500 status code with JSON payload for failed extractions
- Created app/routers/review_queue.py with three endpoints
  - GET /api/review-queue: List pending reviews (paginated, newest first)
  - POST /api/review-queue/{id}/resolve: Mark review as resolved with status and notes
  - GET /api/review-queue/{id}: Get specific review item details
  - All endpoints have rate limiting (100/min for reads, 100/min for writes)
- Updated app/main.py to register review queue router
- **Files changed:** migrations/002_create_review_queue_table.sql (new), app/db/review_queue.py (new), app/routers/review_queue.py (new), app/routers/extraction.py, app/main.py
- **Quality:** All 228 tests passing, mypy strict passing for review queue code
- **Learnings for future iterations:**
  - Review queue uses JOIN to extractions table for file context (file_name, file_hash, status)
  - When extraction_result is None, must use update_extraction_status() not update_extraction()
  - Error type classification helps categorize failures (gemini_api_error, validation_error, processing_error)
  - Constraint in DB ensures resolution and reviewed_at are set together (data integrity)
  - Failed extractions return 500 with JSON body including extraction_id and queued_for_review flag
  - Supabase .single() raises exception if not found - catch and return None for 404 handling

---

