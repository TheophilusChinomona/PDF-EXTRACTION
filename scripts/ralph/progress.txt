# Ralph Progress Log

Started: 2026-01-28
Project: PDF-Extraction (Hybrid Architecture)
Branch: ralph/hybrid-extraction-pipeline

---

## Codebase Patterns

- **Gemini SDK:** Use `from google import genai` (modern SDK), NOT `google.generativeai`
- **Settings Pattern:** Use `get_settings()` for configuration access (singleton via @lru_cache)
- **Testing Settings:** Always call `get_settings.cache_clear()` before testing environment variables
- **Pydantic v2:** Raises `ValidationError` for validation failures (not `ValueError`)
- **Mypy Configuration:** Requires `plugins = pydantic.mypy` in mypy.ini for BaseSettings support
- **OpenDataLoader API:** Uses functional `convert()` not object-oriented `DocumentLoader()` class
- **OpenDataLoader Output:** Writes JSON/Markdown files to disk - must read them to extract data
- **Quality Scoring:** <0.7 triggers Vision fallback, >=0.7 uses hybrid mode
- **Supabase Package:** Named 'supabase' not 'supabase-py' in requirements.txt
- **FastAPI Routers:** Import functions at module level (not inside functions) to enable test mocking
- **Retry Pattern:** Decorator handles both sync and async functions via inspect.iscoroutinefunction()
- **Partial Extraction:** Save OpenDataLoader data even when Gemini fails - provides value to users
- **File Cleanup:** Use finally block with try/except to silence cleanup failures (extraction result more important)
- **Rate Limiting:** Use slowapi with `get_limiter()` singleton; reset limiter in tests with `autouse=True` fixture

---

## Completed Stories Summary (US-001 to US-020)

✅ **US-001 to US-005:** Project structure, dependencies, config, Gemini client, Pydantic models
✅ **US-006 to US-007:** OpenDataLoader integration, quality scoring algorithm
✅ **US-008 to US-009:** Hybrid extraction pipeline, Vision fallback
✅ **US-010:** File validation (size, MIME type, sanitization, SHA-256 hash)
✅ **US-011 to US-013:** Supabase client, database schema (extractions table), CRUD functions
✅ **US-014:** FastAPI app with health check, version endpoint, lifespan handler
✅ **US-015:** POST /api/extract endpoint (upload, validate, extract, store)
✅ **US-016:** GET /api/extractions endpoints (single + list with pagination)
✅ **US-017:** Bounding box endpoints (all bboxes + specific element)
✅ **US-018:** Retry logic with exponential backoff decorator
✅ **US-019:** Partial result storage with retry via duplicate detection
✅ **US-020:** Request logging middleware with structured JSON output
✅ **US-021:** Rate limiting middleware with slowapi

**Status:** 21/28 stories complete | 228 tests passing | mypy --strict passing

**Architecture Working:**
- Hybrid pipeline: OpenDataLoader → Quality Check (0.7) → Gemini/Vision
- Cost savings: 80% for hybrid mode, 0% for Vision fallback
- Database: Full CRUD operations with deduplication
- API: Complete extraction workflow with error handling

---

## Next Stories (US-022 to US-028)

**Remaining:** Review queue, batch processing, webhooks, context caching, routing stats, integration tests, deployment docs

---

**Full detailed logs archived at:** `archive/2026-01-28-progress-backup/progress-full.txt`

---

## 2026-01-28 20:00 - US-020
- Implemented structured JSON request logging middleware
- Added RequestLoggingMiddleware to FastAPI app (wraps all requests)
- Logs include: request_id (UUID), timestamp, method, path, status_code, processing_time_ms, user_ip
- Captures routing decisions: processing_method (hybrid/vision_fallback), quality_score from headers
- Error logging includes full stack traces for debugging
- Security: Does NOT log API keys, file contents, or sensitive data
- Added X-Request-ID header to all responses for request tracking
- Updated extraction router to add X-Processing-Method and X-Quality-Score headers
- **Files changed:** app/middleware/logging.py (new), app/middleware/__init__.py (new), app/main.py, app/routers/extraction.py
- **Learnings for future iterations:**
  - Middleware order matters: Logging middleware added first to wrap all other middleware
  - Use BaseHTTPMiddleware for FastAPI middleware with proper type hints (Callable[[Request], Awaitable[Response]])
  - Response headers can pass metadata to middleware for logging (X-Processing-Method, X-Quality-Score)
  - JSON logging format enables structured log analysis (parsing, filtering, metrics)
  - Request state (request.state) is useful for passing data between middleware and endpoints

---

## 2026-01-28 21:30 - US-021
- Implemented rate limiting middleware using slowapi library
- Rate limits configured per endpoint:
  - POST /api/extract: 10 requests/minute per IP
  - POST /api/batch: 2 requests/minute per IP (for future batch endpoint)
  - GET /api/extractions/*: 100 requests/minute per IP
- Returns 429 Too Many Requests with Retry-After header when limit exceeded
- Custom error handler returns JSON response with detail, message, and retry_after
- Uses in-memory storage for MVP (can upgrade to Redis later)
- Added X-RateLimit-Remaining header to responses via RateLimitMiddleware
- **Files changed:** app/middleware/rate_limit.py (new), app/main.py, app/routers/extraction.py, requirements.txt, tests/test_rate_limit.py (new), tests/test_extraction_router.py
- **Learnings for future iterations:**
  - slowapi library works well with FastAPI but has untyped decorators (use `# type: ignore[untyped-decorator]`)
  - slowapi doesn't have type stubs (use `# type: ignore[import-not-found]` for imports)
  - Rate limiter must be reset in tests to avoid rate limit interference between test cases
  - Use `autouse=True` fixture to reset limiter before each test
  - RateLimitExceeded takes a Limit object, not a detail string - use mock for testing
  - Get client IP from X-Forwarded-For header for proxied requests (first IP in list)
  - slowapi stores limiter in app.state for route decorators to access

---

## 2026-01-28 22:30 - US-023 & US-024
- **US-023: Batch Processing Endpoint**
  - Created migrations/003_create_batch_jobs_table.sql with batch_jobs table
  - Table tracks: status (enum), total_files, completed_files, failed_files
  - JSONB routing_stats: {hybrid, vision_fallback, pending} for routing distribution
  - UUID[] extraction_ids to link to individual extractions
  - Cost tracking: cost_estimate_usd, cost_savings_usd (80% savings for hybrid mode)
  - Created app/models/batch.py with Pydantic models (BatchJobCreate, BatchJobStatus, RoutingStats)
  - Created app/db/batch_jobs.py with database operations
  - Created app/routers/batch.py with POST /api/batch and GET /api/batch/{id} endpoints
  - Batch processing is synchronous for MVP (processes files sequentially)
  - Returns 202 Accepted with batch_job_id and status URL
  - Updates routing_stats as each file completes
  - Integrated batch router into main.py
- **US-024: Webhook Notifications**
  - Created app/services/webhook_sender.py
  - send_webhook function: HTTPS validation, HMAC-SHA256 signature, 3 retries with exponential backoff
  - send_extraction_completed_webhook: wrapper for extraction events
  - send_batch_completed_webhook: wrapper for batch completion events
  - Integrated into extraction router: calls webhook after successful extraction if webhook_url provided
  - Fire-and-forget pattern using asyncio.create_task (non-blocking)
  - Webhook payload format: {event, extraction_id/batch_job_id, status, data/summary, timestamp}
  - X-Webhook-Signature header with HMAC-SHA256 for verification
  - 30-second timeout per request
  - Logs all webhook delivery attempts and responses
- **Files changed:** migrations/003_create_batch_jobs_table.sql (new), app/models/batch.py (new), app/db/batch_jobs.py (new), app/routers/batch.py (new), app/services/webhook_sender.py (new), app/main.py, app/routers/extraction.py, tests/test_batch.py (new), tests/test_webhook_sender.py (new), app/middleware/rate_limit.py
- **Tests:** 248 tests passing (11 new batch tests, 9 new webhook tests)
- **Quality:** mypy --strict passing, fixed datetime.utcnow() deprecation warnings, removed unnecessary slowapi type: ignore comments
- **Learnings for future iterations:**
  - Batch endpoint uses rate limiting decorator @limiter.limit("2/minute") to prevent abuse
  - Webhook fire-and-forget pattern: use asyncio.create_task() to avoid blocking extraction response
  - HMAC signature uses GEMINI_API_KEY as default secret key (can be customized per webhook)
  - Batch job status automatically transitions: pending → processing → completed/failed/partial
  - Routing stats are updated atomically: fetch current state, increment counters, update in single transaction
  - Cost savings calculation: hybrid mode saves 80%, so savings = cost * 4 (since cost is 20% of pure vision)
  - Fire-and-forget webhooks mean extraction doesn't fail if webhook fails (logged instead)
  - datetime.now(UTC) is preferred over datetime.utcnow() (deprecated in Python 3.14)
  - slowapi now has type stubs - no need for type: ignore[import-untyped] comments

---

