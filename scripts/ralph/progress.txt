# Ralph Progress Log

Started: 2026-01-28
Project: PDF-Extraction (Hybrid Architecture)
Branch: ralph/hybrid-extraction-pipeline

---

## Codebase Patterns

- **Gemini SDK:** Use `from google import genai` (modern SDK), NOT `google.generativeai`
- **Settings Pattern:** Use `get_settings()` for configuration access (singleton via @lru_cache)
- **Testing Settings:** Always call `get_settings.cache_clear()` before testing environment variables
- **Pydantic v2:** Raises `ValidationError` for validation failures (not `ValueError`)
- **Mypy Configuration:** Requires `plugins = pydantic.mypy` in mypy.ini for BaseSettings support
- **OpenDataLoader API:** Uses functional `convert()` not object-oriented `DocumentLoader()` class
- **OpenDataLoader Output:** Writes JSON/Markdown files to disk - must read them to extract data
- **Quality Scoring:** <0.7 triggers Vision fallback, >=0.7 uses hybrid mode
- **Supabase Package:** Named 'supabase' not 'supabase-py' in requirements.txt
- **FastAPI Routers:** Import functions at module level (not inside functions) to enable test mocking
- **Retry Pattern:** Decorator handles both sync and async functions via inspect.iscoroutinefunction()
- **Partial Extraction:** Save OpenDataLoader data even when Gemini fails - provides value to users
- **File Cleanup:** Use finally block with try/except to silence cleanup failures (extraction result more important)
- **Rate Limiting:** Use slowapi with `get_limiter()` singleton; reset limiter in tests with `autouse=True` fixture

---

## Completed Stories Summary (US-001 to US-020)

✅ **US-001 to US-005:** Project structure, dependencies, config, Gemini client, Pydantic models
✅ **US-006 to US-007:** OpenDataLoader integration, quality scoring algorithm
✅ **US-008 to US-009:** Hybrid extraction pipeline, Vision fallback
✅ **US-010:** File validation (size, MIME type, sanitization, SHA-256 hash)
✅ **US-011 to US-013:** Supabase client, database schema (extractions table), CRUD functions
✅ **US-014:** FastAPI app with health check, version endpoint, lifespan handler
✅ **US-015:** POST /api/extract endpoint (upload, validate, extract, store)
✅ **US-016:** GET /api/extractions endpoints (single + list with pagination)
✅ **US-017:** Bounding box endpoints (all bboxes + specific element)
✅ **US-018:** Retry logic with exponential backoff decorator
✅ **US-019:** Partial result storage with retry via duplicate detection
✅ **US-020:** Request logging middleware with structured JSON output
✅ **US-021:** Rate limiting middleware with slowapi

**Status:** 21/28 stories complete | 228 tests passing | mypy --strict passing

**Architecture Working:**
- Hybrid pipeline: OpenDataLoader → Quality Check (0.7) → Gemini/Vision
- Cost savings: 80% for hybrid mode, 0% for Vision fallback
- Database: Full CRUD operations with deduplication
- API: Complete extraction workflow with error handling

---

## Next Stories (US-022 to US-028)

**Remaining:** Review queue, batch processing, webhooks, context caching, routing stats, integration tests, deployment docs

---

**Full detailed logs archived at:** `archive/2026-01-28-progress-backup/progress-full.txt`

---

## 2026-01-28 20:00 - US-020
- Implemented structured JSON request logging middleware
- Added RequestLoggingMiddleware to FastAPI app (wraps all requests)
- Logs include: request_id (UUID), timestamp, method, path, status_code, processing_time_ms, user_ip
- Captures routing decisions: processing_method (hybrid/vision_fallback), quality_score from headers
- Error logging includes full stack traces for debugging
- Security: Does NOT log API keys, file contents, or sensitive data
- Added X-Request-ID header to all responses for request tracking
- Updated extraction router to add X-Processing-Method and X-Quality-Score headers
- **Files changed:** app/middleware/logging.py (new), app/middleware/__init__.py (new), app/main.py, app/routers/extraction.py
- **Learnings for future iterations:**
  - Middleware order matters: Logging middleware added first to wrap all other middleware
  - Use BaseHTTPMiddleware for FastAPI middleware with proper type hints (Callable[[Request], Awaitable[Response]])
  - Response headers can pass metadata to middleware for logging (X-Processing-Method, X-Quality-Score)
  - JSON logging format enables structured log analysis (parsing, filtering, metrics)
  - Request state (request.state) is useful for passing data between middleware and endpoints

---

## 2026-01-28 21:30 - US-021
- Implemented rate limiting middleware using slowapi library
- Rate limits configured per endpoint:
  - POST /api/extract: 10 requests/minute per IP
  - POST /api/batch: 2 requests/minute per IP (for future batch endpoint)
  - GET /api/extractions/*: 100 requests/minute per IP
- Returns 429 Too Many Requests with Retry-After header when limit exceeded
- Custom error handler returns JSON response with detail, message, and retry_after
- Uses in-memory storage for MVP (can upgrade to Redis later)
- Added X-RateLimit-Remaining header to responses via RateLimitMiddleware
- **Files changed:** app/middleware/rate_limit.py (new), app/main.py, app/routers/extraction.py, requirements.txt, tests/test_rate_limit.py (new), tests/test_extraction_router.py
- **Learnings for future iterations:**
  - slowapi library works well with FastAPI but has untyped decorators (use `# type: ignore[untyped-decorator]`)
  - slowapi doesn't have type stubs (use `# type: ignore[import-not-found]` for imports)
  - Rate limiter must be reset in tests to avoid rate limit interference between test cases
  - Use `autouse=True` fixture to reset limiter before each test
  - RateLimitExceeded takes a Limit object, not a detail string - use mock for testing
  - Get client IP from X-Forwarded-For header for proxied requests (first IP in list)
  - slowapi stores limiter in app.state for route decorators to access

---

